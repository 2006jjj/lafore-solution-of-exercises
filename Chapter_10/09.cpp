/*10_09ex.cpp
Допустим, что нам нужно сохранить 100 целых чисел так, чтобы иметь к ним легкий доступ. Допустим, что при этом у нас есть проблема:
память нашего компьютера так фрагментирована, что может хранить массив, наибольшее количество элементов в котором равно десяти (такие проблемы действительно
появляются, хотя обычно это происходит с объектами, занимающими большое количество памяти). Вы можете решить эту проблему, определив 10 разных массивов по 10 элементов
в каждом и массив из 10 указаталей на эти массивы. Массивы будут иметь имена а0, а1, а2 и т.д. Адрес каждого массива будет сохранен в массиве указателей типа int*, который
называется ap. Вы сможете получить доступ к отдельному целому используя выражение ap[j][k], где j является номером элемента массива указателей, а k - номером элемента в массиве,
на который этот указатель указывает. Это похоже на двумерный массив, но в действительности является группой одномерных массивов.
Заполните группу массивов тестовыми данными (скажем, номерами 0, 10, 20 и т.д.), а затем выведите их, чтобы убедиться, что все работает правильно.*/

#include <iostream>
using namespace std;

int main()
{setlocale(LC_ALL, ".1251"); system("color 0F"); srand(time(NULL));

const int SIZE = 10;
int a0[SIZE], a1[SIZE], a2[SIZE], a3[SIZE], a4[SIZE],
a5[SIZE], a6[SIZE], a7[SIZE], a8[SIZE], a9[SIZE],
j, k;
int* ap[SIZE] = { a0, a1, a2, a3, a4, a5, a6, a7, a8, a9 };
 
for (j = 0; j < SIZE; j++)
	for (k = 0; k < SIZE; k++)
		ap[j][k] = (j * SIZE + k) * SIZE;
 
for (int j = 0; j < SIZE; j++)
	for (int k = 0; k < SIZE; k++)
		cout << ap[j][k] << ((k == SIZE - 1) ? "\n" : " "); 

cout << endl; system("pause"); return 0;
}
