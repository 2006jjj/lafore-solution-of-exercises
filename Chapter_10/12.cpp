/*10_12ex.cpp
Указатели сложны, поэтому давайте посмотрим, сможем ли мы сделать работу с ними более понятной (или, возможно, более непонятной), используя их симуляцию в классе.
Для разъяснения действия наших доморощенных указателей мы смоделируем память компьютера с помощью массивов. Так как доступ к массивам всем понятен, то вы сможете увидеть,
что реально происходит, когда мы используем для доступа к памяти указатели.
Мы будем использовать один массив типа char для хранения всех типов переменных. Именно так устроена память компьютера: массив байтов (тип char имеет тот же размер),
каждый из которых имеет адрес (или, в терминах массива, индекс). Однаком С++ не позволит нам хранить данные типа float или int в массиве типа char обычным путем (мы можем использовать
объединения, но это другая история). Поэтому мы создадим симулятор памяти, используя отдельный массив для каждого типа данных, которые мы хотим сохранить. В этом упражнении мы ограничимся одним
типом float, а нам понадобится массив для него. Назовем этот массив fmemory. Однако значения указателей (адреса) тоже хранятся в памяти, и нам понадобится еще один массив для их хранения.
Так как в качестве модели адресов мы используем индексы массива, то нам потребуется массив типа int, назовем его pmemory, для хранения этих индексов.
Индекс массива fmemory (назовем его fmem_top) показывает на следующее по очереди доступное место, где можно сохранить значение типа float. У нас есть еще похожий индекс массива pmemory
(назовем его pmem_top). Не волнуйтесь о том, что наша "память" может закончиться. Мы предполагаем, что эти массивы достаточно большие, чтобы хранить все, что мы захотим, и нам не надо
заботиться об управлении памятью. 
Создадим класс Float, который мы будем использовать для моделирования чисел типа float, которые будет храниться в fmemory вместо настоящей памяти. Класс Float содержит поле, значением которого
является индекс массива fmemory, хранящего значения типа float. Назовем это поле addr. В классе также должны быть два метода. Первый - это конструктор, имеющий один аргумент типа float 
для инициализации значения. Конструктор помещает значение аргумента в элемент массива fmemory, на который указывает указатель fmem_top, а затем записывает значение fmem_top в массив addr.
Это похоже на то, как компоновщик и компилятор хранят обычные перменные в памяти. Второй метод является перегружаемой операцией &. Он просто возвращает значение указателя (индекса типа int) в addr.
Создадим второй класс ptrFloat. Объект этого класса содержит адрес (индекс) в pmemory. Метод класса инициализирует этот "указатель" значением типа int. Второй метод перегружает операцию * (операция
разыменования). Его действия более сложны. Он получает адрес из массива pmemory, в котором хранятся адреса. Затем полученный адрес используется как индекс массива fmemory для получения значения типа 
float, которое располагалось по нужному нам адресу.
  float& ptrFloat::operator* ()
  {
    return fmemory [pmemory[addr]];
  }
Таким образом мы моделируем действия операции разыменования (*). Заметим, что вам нужно возвращаться из этой функции по ссылке, чтобы можно было использовать операцию * слева от знака равно.
Классы Float и ptrFloat похожи, но класс Float хранит данные типа float в массиве, представляющем собой память, а класс ptrFloat хранит поля типа int (являющиеся у нас указателями, но на 
самом деле индексами массива) в другом массиве, который тоже представляет собой память.
Это типичное использование этих классов в функции main():
  Float var1 = 1.234;
  Float var2 = 5.678;
  
  ptrFloat ptr1 = &var1;
  ptrFloat ptr2 = &var2;
  
  cout << " *ptr1 = " << *ptr1;
  cout << " *ptr2 = " << *ptr2;
  
Заметим, что за исключением других имен типов перменных, это выглядит так же, как действия с настоящими переменными. Далее результат работы программы:
  *ptr1 = 1.234;
  *ptr2 = 5.678;
  
  *ptr1 = 7.123;
  *ptr2 = 8.456;
Такой путь реализации указателей может показаться очень сложным, но здесь показана их внутренняя работа и работа операции адреса. Мы рассмотрели природу указателей в различных ракурсах.*/


#include <iostream>
using namespace std;

float fmemory[10]; 
int fmem_top = 0;

int pmemory[10]; 
int pmem_top = 0;

class Float
{
private: 
  int addr;
public:
Float(float value) 
{
  fmemory[fmem_top] = value;
  addr = fmem_top;
  fmem_top++;
}
int operator& () const 
{ 
  return addr; 
}
};

class ptrFloat 
{
private: 
  int addr;
public:
ptrFloat(int value) 
{
  pmemory[pmem_top] = value;
  addr = pmem_top;
  pmem_top++;
}
float& operator* () const 
{ 
  return fmemory[pmemory[addr]];
}
};

int main()
{setlocale(LC_ALL, ".1251"); system("color 0F"); srand(time(NULL));

Float var1 = 1.234; 
Float var2 = 5.678;
ptrFloat ptr1 = &var1; 
ptrFloat ptr2 = &var2;
cout << " *ptr1 = " << *ptr1 << endl; 
cout << " *ptr2 = " << *ptr2 << endl;
*ptr1 = 7.123; 
*ptr2 = 8.456;
cout << "\n *ptr1 = " << *ptr1 << endl; 
cout << " *ptr2 = " << *ptr2 << endl;

cout << endl; system("pause"); return 0;
}
