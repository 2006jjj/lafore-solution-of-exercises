/*12_06ex.cpp
Создайте класс name, включающий в себя данные из упр. 4 (имя, отчество, фамилия и номер работника). Создайте методы для этого класса, осуществляющие файловый ввод/вывод
данных указанного класса (с использованием ofstream и ifstream). Используйте форматирование данных (операторы << и >>). Функции чтения и записи должны быть независимыми:
в них необходимо внести выражения для открытия соответствующего потока, а также чтения и записи данных.
Функция записи может просто добавлять данные в конец файла. Функции чтения потребуется некоторое условие выборки конкретной записи. Можно вызывать ее с параметром,
представляющим собой номер записи. Но как, даже зная, какую запись следует читать, функция найдет ее? Использование seekg() тут не поможет, так как при форматированном вводе/выводе
все записи имеют разные размеры (в зависимости от количества символов в строке и разрядности числа). Поэтому придется просто считывать записи подряд, пока не будет найдена нужная.
В main() вставьте вызовы описанных выше методов, чтобы пользователь мог ввести данные с их последующей записью в файл. Затем программа должна выполнить чтение и продемонстрировать
результаты этого чтения на экране.


12_07ex.cpp
Другим подходом к добавлению файлового потока к объекту является превращение самого этого потока в статическую компоненту объекта. Для чего это делается?
Ну, часто бывает проще представить себе поток связанным с классом в целом, а не с отдельными его объектами. К тому же, гораздо правильнее открывать поток только один раз
для записи и чтения всего, что нужно. Например, мы открываем файл и начинаем последовательное чтение. Функция чтения всякий раз возвращает данные для следующего объекта.
Указатель файла сдвигается при этом автоматически, так как между чтениями файл мы не закрываем.
Перепишите программы из упр. 4 и 6 таким образом, чтобы использовать объект fstream в качестве статической компоненты класса name. Функционирование программы должно сохраниться.
Напишите статическую функцию для открытия поток и еще одну - для сбрасывания файлового указателя и установки его на начало файла. Эту же функцию можно использовать для чтения всего файла.*/

#include <fstream> 
#include <iostream>
#include <string> 
#include <codecvt>
#include <locale>
using namespace std;

class name 
{
private:
  string name, surname, otc;
  unsigned long number;
  static fstream file;
public:
void getData()
{
  cout << "\nВведите номер сотрудника:"; 
  cin >> number;
  cout << "\nВведите фамилия, имя и отчество (через пробел):"; 
  cin >> surname >> name >> otc;
}
void showData()
{
  cout << "\nНомер сотрудника:" << number;
  cout << "\nФамилия, имя и отчество: " << surname << " " << name << " " << otc << endl;
}
static void diskOpen();
void diskOut();
void diskIn(int n);
static int diskCount();
};

fstream name::file;

void name::diskOpen()
{
  file.open("E://TEST//Z12-4.TXT", ios::app | ios::out | ios::in);
  if (!file) 
  {
    cout << "Error!";
    exit(-1); 
  }
}

void name::diskOut() 
{
  file << number << surname << " " << name << " " << otc << endl; 
}

void name::diskIn(int n)
{
  file.seekg(0);
  int count = 1;
  while (file >> number >> surname >> name >> otc && count != n)
    count++;
}

int name::diskCount()
{
  string name, surname, otc; 
  unsigned long number;
  file.seekg(0); 
  int count = 0;
  while (file >> number >> surname >> name >> otc)
    count++;
  file.clear();
  return count;
}

int main()
{setlocale(LC_ALL, ".1251"); system("color 0F"); srand(time(NULL));

name n1; 
char ch;
name::diskOpen();
do
{
  cout << "Введите данные о человеке:";
  n1.getData();
  n1.diskOut();
  cout << "Продолжить или нет? y/n:"; 
  cin >> ch;
} while (ch != 'n');

int x = name::diskCount();
cout << "\nВ ФАЙЛЕ " << x << " ЗАПИСЕЙ\n";
for (int j = 1; j <= x; j++)
{
  cout << "\nЗапись " << j << ":";
  n1.diskIn(j);
  n1.showData();
}

cout << endl; system("pause"); return 0;
}
